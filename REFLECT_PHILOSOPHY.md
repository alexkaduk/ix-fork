# The `reflect` Property Philosophy in Siemens IX

## Why This Document Exists

When building Web Components with Stencil, every `@Prop()` can optionally have `reflect: true`. This document clarifies **when to use reflection and why**, ensuring consistency across the IX design system for both contributors and consumers.

---

## The Problem

Without clear guidelines, developers face questions like:
- "Should this property be reflected to a DOM attribute?"
- "Why does `disabled` use `reflect: true` but `variant` doesn't?"
- "How do I know when reflection is needed?"

Inconsistent reflection leads to:
- ‚ùå Performance issues (unnecessary DOM updates)
- ‚ùå Security concerns (exposed sensitive data)
- ‚ùå Debugging confusion (invisible state)
- ‚ùå CSS styling problems (can't target attributes)

---

## What is `reflect`?

### Without `reflect` (Default: `false`)
```tsx
@Prop() disabled = false;
```

**Behavior:** Property ‚Üí DOM attribute (one-way)
```html
<!-- HTML attribute sets property -->
<ix-button disabled="true"></ix-button>

<!-- JavaScript changes property -->
<script>
  button.disabled = false;
</script>

<!-- Attribute NOT updated in DOM -->
<ix-button disabled="true"></ix-button>  
<!-- ‚ùå Still shows "true" in DOM, but button.disabled === false -->
```

### With `reflect: true`
```tsx
@Prop({ reflect: true }) disabled = false;
```

**Behavior:** Property ‚Üî DOM attribute (two-way sync)
```html
<!-- HTML attribute sets property -->
<ix-button disabled="true"></ix-button>

<!-- JavaScript changes property -->
<script>
  button.disabled = false;
</script>

<!-- Attribute SYNCS automatically -->
<ix-button disabled="false"></ix-button>  
<!-- ‚úÖ Updates in DOM to match property -->
```

---

## The Philosophy: "Reflect Only What Needs Observation"

### Core Principle
**Reflect properties only when external systems (CSS, browsers, DevTools, accessibility tools) need to observe their changes.**

Keep everything else private for **performance, security, and encapsulation**.

---

## When to Use `reflect: true` ‚úÖ

### 1. **Form-Associated Properties** (Web Standards)

Mirror native HTML form element behavior:

```tsx
// Matches <input name=""> behavior
@Prop({ reflect: true }) name?: string;

// Matches <input value=""> behavior  
@Prop({ reflect: true }) value: string;

// Matches <input checked> behavior
@Prop({ reflect: true }) checked = false;

// Matches <input disabled> behavior
@Prop({ reflect: true }) disabled = false;

// Matches <input required> behavior
@Prop({ reflect: true }) required = false;
```

**Why?**
- ‚úÖ **Standards Compliance**: Follows HTML form specification
- ‚úÖ **Form Validation**: Browsers read attributes for validation (`[required]`)
- ‚úÖ **Framework Integration**: Angular, React forms expect attributes
- ‚úÖ **Accessibility**: Screen readers detect `[disabled]`, `[required]`

**Real Example:**
```tsx
// checkbox.tsx
@Component({
  tag: 'ix-checkbox',
  formAssociated: true,
})
export class Checkbox {
  @Prop({ reflect: true }) name?: string;
  @Prop({ reflect: true }) value: string = 'on';
  @Prop({ reflect: true }) checked: boolean = false;
  @Prop({ reflect: true }) disabled: boolean = false;
  @Prop({ reflect: true }) required = false;
}
```

---

### 2. **CSS-Dependent State** (Styling Requirements)

Reflect when CSS selectors need to target the attribute:

```tsx
@Prop({ reflect: true }) disabled = false;
```

```scss
// CSS can style based on attribute
:host([disabled]) {
  opacity: 0.5;
  cursor: not-allowed;
  pointer-events: none;
}

// Or attribute selectors
ix-button[disabled] {
  background-color: var(--theme-color-weak);
}
```

**Why?**
- ‚úÖ **CSS Selectors**: Enables `[attribute]` selectors
- ‚úÖ **State Visibility**: Visual state matches DOM state
- ‚úÖ **Theme Consistency**: Theme CSS can target attributes

**Real Example:**
```tsx
// button.tsx
@Prop({ reflect: true }) disabled = false;

// toggle-button.tsx  
@Prop({ reflect: true }) disabled = false;
```

---

### 3. **Boolean State Flags** (Visible State)

Reflect boolean properties that represent visible component state:

```tsx
@Prop({ reflect: true, mutable: true }) checked = false;
@Prop({ reflect: true }) indeterminate = false;
@Prop({ reflect: true }) expanded = false;
```

**Why?**
- ‚úÖ **DevTools Visibility**: Easy to inspect state in browser
- ‚úÖ **Debugging**: State changes visible in Elements panel
- ‚úÖ **CSS Styling**: Conditional styles based on state

**Real Example:**
```tsx
// toggle.tsx
@Prop({ mutable: true, reflect: true }) checked = false;
@Prop({ mutable: true, reflect: true }) indeterminate = false;

// Usage
<ix-toggle checked="true" indeterminate="false"></ix-toggle>
```

---

### 4. **Accessibility Attributes** (A11y)

Reflect properties that map to ARIA attributes:

```tsx
@Prop({ reflect: true }) ariaExpanded = false;
@Prop({ reflect: true }) ariaSelected = false;
```

**Why?**
- ‚úÖ **Screen Readers**: Assistive technology reads DOM attributes
- ‚úÖ **Standards**: ARIA spec requires DOM attributes, not just properties

---

## When to Use `reflect: false` (Default) ‚ùå

### 1. **Text Content / Strings** (Performance)

Do NOT reflect text content or large strings:

```tsx
// ‚ùå DON'T reflect text
@Prop() label?: string;
@Prop() placeholder?: string;
@Prop() helperText?: string;
@Prop() errorText?: string;

// ‚úÖ Keep as properties only
```

**Why?**
- ‚ö° **Performance**: Avoid serializing large strings to DOM
- üîí **Encapsulation**: Text is internal rendering concern
- üì¶ **Size**: Large attributes bloat DOM

**Real Example:**
```tsx
// toggle.tsx
@Prop() textOn = 'On';              // NO reflect
@Prop() textOff = 'Off';            // NO reflect
@Prop() textIndeterminate = 'Mixed'; // NO reflect

// checkbox.tsx
@Prop() label?: string;              // NO reflect
```

---

### 2. **Complex Data Types** (Can't Serialize)

Never reflect objects, arrays, or functions:

```tsx
// ‚ùå NEVER reflect complex types
@Prop() items: any[] = [];
@Prop() config: object = {};
@Prop() onClick?: () => void;

// ‚úÖ Properties only (but consider slots for items!)
```

**Why?**
- ‚ùå **Can't Serialize**: Objects/arrays can't convert to attribute strings
- ‚ö° **Performance**: Huge performance cost if attempted
- üîí **Security**: May expose internal data structures

**Better Alternative for Lists:**
For arrays of items, consider using **slots** instead of props:

```tsx
// ‚ùå Don't pass items as array prop
<ix-select items={[{id: 1, label: 'Option 1'}, ...]}></ix-select>

// ‚úÖ Use slots (Web Components best practice)
<ix-select>
  <ix-select-item value="1">Option 1</ix-select-item>
  <ix-select-item value="2">Option 2</ix-select-item>
</ix-select>
```

**Benefits of Slots:**
- ‚úÖ Better performance (no serialization)
- ‚úÖ More flexible (custom markup)
- ‚úÖ Composable (nest components)
- ‚úÖ Declarative (HTML-first)

---

### 3. **Configuration Values** (Internal Logic)

Do NOT reflect configuration or variant properties:

```tsx
// ‚ùå DON'T reflect variants/config
@Prop() variant: 'primary' | 'secondary' = 'primary';
@Prop() size: 'small' | 'medium' | 'large' = 'medium';
@Prop() alignment: 'start' | 'center' | 'end' = 'center';

// ‚úÖ Use CSS classes instead
```

**Why?**
- üé® **CSS Classes**: Variants typically use classes, not attributes
- ‚ö° **Performance**: No need for DOM sync
- üì¶ **Encapsulation**: Configuration is internal concern

**Real Example:**
```tsx
// button.tsx
@Prop() variant: ButtonVariant = 'primary';  // NO reflect
@Prop() type: 'button' | 'submit' = 'button'; // NO reflect
@Prop() alignment: 'center' | 'start' = 'center'; // NO reflect

// pane.tsx
@Prop() variant: 'floating' | 'inline' = 'inline';  // NO reflect
@Prop() size: '240px' | '320px' | ... = '240px';    // NO reflect
```

---

### 4. **Boolean Flags (Non-Visual)** (Internal State)

Do NOT reflect boolean flags that are purely for internal logic:

```tsx
// ‚ùå DON'T reflect internal flags
@Prop() hideText = false;
@Prop() hideOnCollapse = false;
@Prop() closeOnClickOutside = false;
@Prop() loading = false;

// ‚úÖ Internal logic only
```

**Why?**
- üîí **Encapsulation**: Implementation details
- ‚ö° **Performance**: No external observer needs this
- üé® **CSS**: Use classes, not attributes

**Real Example:**
```tsx
// toggle.tsx
@Prop() hideText = false;            // NO reflect

// pane.tsx
@Prop() hideOnCollapse: boolean = false;  // NO reflect
@Prop() closeOnClickOutside = false;      // NO reflect

// button.tsx
@Prop() loading: boolean = false;         // NO reflect
```

---

### 5. **Sensitive Data** (Security)

NEVER reflect passwords, tokens, or sensitive information:

```tsx
// ‚ùå NEVER reflect sensitive data
@Prop() password = '';
@Prop() apiToken = '';
@Prop() secretKey = '';

// ‚úÖ Keep in memory only
```

**Why?**
- üîí **Security**: Visible in DOM inspector
- üîç **Audit Risk**: Attributes logged/captured
- üö® **Best Practice**: Sensitive data should never touch DOM

---

### 6. **Frequently Changing Values** (Performance)

Do NOT reflect values that change rapidly:

```tsx
// ‚ùå DON'T reflect high-frequency changes
@Prop() currentTime = 0;
@Prop() scrollPosition = 0;
@Prop() mouseX = 0;

// ‚úÖ State only
```

**Why?**
- ‚ö° **Performance**: Each change triggers DOM write
- üìä **Overhead**: Unnecessary serialization cost

---

### 7. **Internal/Private Props** (API Design)

Do NOT reflect internal or private properties:

```tsx
/** @internal */
@Prop() ignoreLayoutSettings = false;  // NO reflect

/** @internal */
@Prop() isMobile = false;              // NO reflect
```

**Why?**
- üîí **API Privacy**: Not part of public API
- üì¶ **Encapsulation**: Implementation detail

**Real Example:**
```tsx
// pane.tsx
/**
 * @internal
 * Prevents overwriting of variant when used inside layout
 */
@Prop() ignoreLayoutSettings: boolean = false;  // NO reflect

/** @internal */
@Prop({ mutable: true }) isMobile: boolean = false;  // NO reflect
```

---

## Decision Tree üå≤

```
Does external system need to observe this property?
‚îÇ
‚îú‚îÄ YES ‚Üí Is it a form property (name, value, checked, disabled)?
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ YES ‚Üí ‚úÖ USE reflect: true (Web Standards)
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ NO ‚Üí Does CSS need to style based on this?
‚îÇ       ‚îÇ
‚îÇ       ‚îú‚îÄ YES ‚Üí ‚úÖ USE reflect: true (CSS Selectors)
‚îÇ       ‚îÇ
‚îÇ       ‚îî‚îÄ NO ‚Üí Is it a boolean state flag (checked, expanded)?
‚îÇ           ‚îÇ
‚îÇ           ‚îú‚îÄ YES ‚Üí ‚úÖ USE reflect: true (Visibility)
‚îÇ           ‚îÇ
‚îÇ           ‚îî‚îÄ NO ‚Üí Is it for accessibility (ARIA)?
‚îÇ               ‚îÇ
‚îÇ               ‚îú‚îÄ YES ‚Üí ‚úÖ USE reflect: true (A11y)
‚îÇ               ‚îÇ
‚îÇ               ‚îî‚îÄ NO ‚Üí ‚ùå USE reflect: false (Default)
‚îÇ
‚îî‚îÄ NO ‚Üí ‚ùå USE reflect: false (Default)
    ‚îÇ
    ‚îî‚îÄ Is it text, object, array, or sensitive?
        ‚îÇ
        ‚îú‚îÄ YES ‚Üí ‚ùå NEVER reflect (Security/Performance)
        ‚îÇ
        ‚îî‚îÄ NO ‚Üí Is it configuration or internal?
            ‚îÇ
            ‚îî‚îÄ YES ‚Üí ‚ùå NEVER reflect (Encapsulation)
```

---

## Quick Reference Table üìä

| Property Type | `reflect` | Example | Reason |
|---------------|-----------|---------|--------|
| **Form attributes** | ‚úÖ `true` | `name`, `value`, `checked`, `disabled`, `required` | Web standards, form validation, CSS |
| **Interactive state** | ‚úÖ `true` | `checked`, `expanded`, `selected` | CSS styling, DevTools visibility |
| **ARIA attributes** | ‚úÖ `true` | `ariaExpanded`, `ariaSelected` | Accessibility, screen readers |
| **Text content** | ‚ùå `false` | `label`, `placeholder`, `helperText` | Performance, encapsulation |
| **Configuration** | ‚ùå `false` | `variant`, `size`, `alignment` | CSS classes, internal logic |
| **Boolean flags (internal)** | ‚ùå `false` | `hideText`, `loading`, `closeOnClickOutside` | Encapsulation, no CSS dependency |
| **Complex types** | ‚ùå `false` | `items[]`, `config{}`, functions | Can't serialize |
| **Sensitive data** | ‚ùå `false` | `password`, `token` | Security |
| **High-frequency** | ‚ùå `false` | `currentTime`, `scrollPosition` | Performance |
| **Internal/private** | ‚ùå `false` | `@internal` props | API privacy |

---

## Code Examples

### ‚úÖ Good: Form Component (reflect: true)
```tsx
@Component({
  tag: 'ix-checkbox',
  formAssociated: true,
})
export class Checkbox {
  // ‚úÖ Reflect form-related properties
  @Prop({ reflect: true }) name?: string;
  @Prop({ reflect: true }) value: string = 'on';
  @Prop({ reflect: true }) checked: boolean = false;
  @Prop({ reflect: true }) disabled: boolean = false;
  @Prop({ reflect: true }) required = false;
  
  // ‚ùå Don't reflect text content
  @Prop() label?: string;
}
```

### ‚úÖ Good: Button Component (mixed)
```tsx
@Component({
  tag: 'ix-button',
})
export class Button {
  // ‚úÖ Reflect disabled for CSS styling
  @Prop({ reflect: true }) disabled = false;
  
  // ‚ùå Don't reflect variant (uses CSS classes)
  @Prop() variant: ButtonVariant = 'primary';
  
  // ‚ùå Don't reflect type (internal logic)
  @Prop() type: 'button' | 'submit' = 'button';
  
  // ‚ùå Don't reflect loading (internal state)
  @Prop() loading = false;
  
  // ‚ùå Don't reflect text/icon
  @Prop() icon?: string;
}
```

### ‚ùå Bad: Over-reflecting
```tsx
// ‚ùå DON'T DO THIS
@Component({ tag: 'ix-card' })
export class Card {
  @Prop({ reflect: true }) title?: string;        // ‚ùå Text content
  @Prop({ reflect: true }) items: any[] = [];     // ‚ùå Complex data
  @Prop({ reflect: true }) config: object = {};   // ‚ùå Object
  @Prop({ reflect: true }) variant = 'default';   // ‚ùå Configuration
  @Prop({ reflect: true }) loading = false;       // ‚ùå Internal flag
}

// ‚úÖ CORRECT VERSION
@Component({ tag: 'ix-card' })
export class Card {
  @Prop() title?: string;        // ‚úÖ Text content (or use slot)
  // ‚ùå Don't use items prop - use slots instead!
  @Prop() config: object = {};   // ‚úÖ Object (internal only)
  @Prop() variant = 'default';   // ‚úÖ Configuration
  @Prop() loading = false;       // ‚úÖ Internal flag
  
  render() {
    return (
      <Host>
        <slot name="header"></slot>  {/* ‚úÖ Use slots for content */}
        <slot></slot>
        <slot name="footer"></slot>
      </Host>
    );
  }
}
```

### ‚úÖ Good: Using Slots for Items
```tsx
// ‚úÖ RECOMMENDED: Slots over array props
@Component({ tag: 'ix-list' })
export class List {
  render() {
    return (
      <Host>
        <slot></slot>  {/* Accept ix-list-item children */}
      </Host>
    );
  }
}

// Usage
<ix-list>
  <ix-list-item>Item 1</ix-list-item>
  <ix-list-item>Item 2</ix-list-item>
  <ix-list-item>Item 3</ix-list-item>
</ix-list>

// ‚ùå AVOID: Array props for content
@Component({ tag: 'ix-list' })
export class List {
  @Prop() items: string[] = [];  // Avoid this pattern
}
```

---

## Testing Reflection

### Check if reflection is working:
```tsx
// Component
@Prop({ reflect: true }) disabled = false;

// Test
const button = document.querySelector('ix-button');
button.disabled = true;

// Check DOM
console.log(button.getAttribute('disabled')); 
// ‚úÖ With reflect: true ‚Üí "true"
// ‚ùå Without reflect: null
```

### Verify in DevTools:
```html
<!-- With reflect: true -->
<ix-button disabled="true">Click</ix-button>

<!-- Without reflect -->
<ix-button>Click</ix-button>
<!-- disabled property exists but not visible -->
```

---

## Common Mistakes to Avoid

### ‚ùå Mistake 1: Reflecting everything "just in case"
```tsx
// ‚ùå BAD
@Prop({ reflect: true }) variant = 'primary';
@Prop({ reflect: true }) label = '';
@Prop({ reflect: true }) config = {};
```

**Impact:** Performance degradation, bloated DOM

---

### ‚ùå Mistake 2: Not reflecting form properties
```tsx
// ‚ùå BAD
@Component({ formAssociated: true })
export class Input {
  @Prop() name?: string;      // Should reflect!
  @Prop() value = '';         // Should reflect!
  @Prop() required = false;   // Should reflect!
}
```

**Impact:** Form validation breaks, CSS selectors fail

---

### ‚ùå Mistake 3: Reflecting sensitive data
```tsx
// ‚ùå BAD - PASSWORD VISIBLE IN DOM!
@Prop({ reflect: true }) password = '';

// ‚úÖ GOOD
@Prop() password = '';
```

**Impact:** Security vulnerability

---

### ‚ùå Mistake 4: Reflecting without CSS need
```tsx
// ‚ùå BAD - No CSS uses this
@Prop({ reflect: true }) loading = false;

// CSS uses classes instead
.loading { /* ... */ }

// ‚úÖ GOOD
@Prop() loading = false;
```

**Impact:** Unnecessary performance cost

---

## Summary

### The Golden Rule
**"Reflect only what needs to be observed. Keep everything else private."**

### Default Approach
```tsx
// Start with NO reflection (default)
@Prop() myProp = 'value';

// Add reflection ONLY when needed
@Prop({ reflect: true }) disabled = false;  // CSS/Forms need it
```

### Key Principles
1. ‚úÖ **Follow Web Standards**: Mirror native HTML for forms
2. ‚ö° **Optimize Performance**: Don't reflect unless necessary
3. üîí **Ensure Security**: Never reflect sensitive data
4. üé® **Enable Styling**: Reflect when CSS needs it
5. ‚ôø **Support Accessibility**: Reflect ARIA attributes
6. üîç **Aid Debugging**: Reflect visible state flags
7. üì¶ **Maintain Encapsulation**: Keep internals private

---

## Questions?

If you're unsure whether to reflect a property, ask:
1. Does CSS need to style based on this attribute?
2. Is this a form property (matching native `<input>`)?
3. Is this a boolean state that should be visible in DevTools?
4. Do accessibility tools need to read this attribute?

**If NO to all ‚Üí Don't reflect (default)**
**If YES to any ‚Üí Reflect (`reflect: true`)**

---

## Testing Components with Non-Reflected Properties

### For Consumers

Many properties (like `icon`, `variant`, `label`) are **not reflected** for performance and encapsulation reasons. When testing, access them via **properties**, not attributes.

#### ‚ùå This Won't Work:
```tsx
const button = screen.getByRole('button');
expect(button.getAttribute('icon')).toBe('check');  // ‚ùå Returns null
expect(button.getAttribute('variant')).toBe('primary');  // ‚ùå Returns null
```

#### ‚úÖ Test Properties Instead:
```tsx
const button = screen.getByRole('button');
expect(button.icon).toBe('check');
expect(button.variant).toBe('primary');
```

#### Using Testing Library:
```tsx
import { screen } from '@testing-library/dom';

const button = screen.getByRole('button');
expect(button).toHaveProperty('icon', 'check');
expect(button).toHaveProperty('variant', 'primary');
```

#### Using Playwright:
```tsx
const button = page.locator('ix-button');
const icon = await button.evaluate((el: HTMLIxButtonElement) => el.icon);
expect(icon).toBe('check');
```

#### Multiple Options:
```tsx
const button = screen.getByRole('button');

expect(button.icon).toBe('check');
expect(button).toHaveProperty('icon', 'check');

const iconElement = button.shadowRoot?.querySelector('ix-icon');
expect(iconElement).toBeInTheDocument();
```

### Quick Reference: How to Test

| Property Type | Reflected? | Test Via Attribute | Test Via Property |
|--------------|------------|-------------------|-------------------|
| `disabled`, `checked`, `required` | ‚úÖ Yes | ‚úÖ `getAttribute('disabled')` | ‚úÖ `element.disabled` |
| `icon`, `variant`, `size` | ‚ùå No | ‚ùå Returns `null` | ‚úÖ `element.icon` |
| `label`, `placeholder` | ‚ùå No | ‚ùå Returns `null` | ‚úÖ `element.label` |

### Why Not Reflect Everything?

While reflecting all properties would make attribute testing easier, it comes with significant costs:

**Performance Impact:**
```tsx
// If we reflected icon (BAD)
@Prop({ reflect: true }) icon = 'check';

// Every icon change = DOM write
button.icon = 'save';    // Triggers DOM update
button.icon = 'delete';  // Triggers DOM update
button.icon = 'edit';    // Triggers DOM update
// 3 DOM updates = expensive!

// Without reflection (GOOD)
button.icon = 'save';    // Property change only
button.icon = 'delete';  // Property change only
button.icon = 'edit';    // Property change only
// 0 DOM updates = fast!
```

**Security Considerations:**
```tsx
// Don't expose internal configuration to DOM
@Prop() apiEndpoint = '/api/users';  // Keep private
@Prop() debugMode = true;            // Keep private
```

---

## Contributing

When adding new components or properties, follow this philosophy. During code review, we'll verify:
- ‚úÖ Form properties are reflected
- ‚úÖ CSS-dependent states are reflected  
- ‚úÖ Text content is NOT reflected
- ‚úÖ Complex data is NOT reflected
- ‚úÖ Sensitive data is NOT reflected

---

**Document Version**: 1.1  
**Last Updated**: 2025-01-11  
**Maintainers**: Siemens IX Team

